"""
Задание 1.

Выполните профилирование памяти в скриптах
Проанализировать результат и определить программы с
наиболее эффективным использованием памяти.

Примечание: Для анализа возьмите любые 1-5 ваших разных скриптов!.
Сделать их разные реализации.

Можно взять задачи с курса Основ
или с текущего курса Алгоритмов

Результаты анализа вставьте в виде комментариев к коду.
Также укажите в комментариях версию Python и разрядность вашей ОС.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО

Попытайтесь дополнительно свой декоратор используя ф-цию memory_usage из memory_profiler
С одновременным замером времени (timeit.default_timer())!
"""

import timeit
from memory_profiler import profile, memory_usage


def mem_check(funck):
    def check_funck():
        mem_diff = []
        for i in range(5):
            m_start = memory_usage()

            funck()
            m_end = memory_usage()
            print(f'Использование памяти при старте: {m_start}')
            print(f'Использование памяти при завершении: {m_end}')
            mem_diff.append(m_end[0] - m_start[0])
            print(f'Инкремент памяти: {sum(mem_diff) / 5} Mib')

    return check_funck


@profile
def func_1():
    nums = list(range(50000))
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    # print(new_arr)


''' 
Line #    Mem usage    Increment  Occurences   Line Contents
============================================================
    59    102.7 MiB    102.7 MiB           1   @profile
    60                                         def func_1():
    61    104.5 MiB      1.8 MiB           1       nums =list(range(50000))
    62    104.5 MiB      0.0 MiB           1       new_arr = []
    63    105.6 MiB      0.0 MiB       50001       for i in range(len(nums)):
    64    105.6 MiB      0.8 MiB       50000           if nums[i] % 2 == 0:
    65    105.6 MiB      0.3 MiB       25000               new_arr.append(i)
    66    105.8 MiB      0.3 MiB           1       print(new_arr)

По профилированию видно что самы большой инкремент у списка nums
процедура требует оптимизации удаления ссылок на объект списка и итератор заменить на генератор
ниже оптимизируем
'''


@profile
def func_1_ver_2():
    nums = [i for i in range(50000)]
    new_arr = [i for i in range(len(nums)) if nums[i] % 2 == 0]
    # print(new_arr)
    del nums
    del new_arr


'''
Line #    Mem usage    Increment  Occurences   Line Contents
============================================================
    82    103.9 MiB    103.9 MiB           1   @profile
    83                                         def func_1_ver_2():
    84    105.1 MiB      1.2 MiB       50003       nums =[i for i in range(50000)]
    85    105.9 MiB      0.8 MiB       50003       new_arr = [i for i in range(len(nums))  if nums[i] % 2 == 0 ]
    86    105.9 MiB      0.0 MiB           1       print(new_arr)
    87    104.7 MiB     -1.2 MiB           1       del nums
    88    104.2 MiB     -0.5 MiB           1       del new_arr

После оптимизации декримент уменшился
и удаление ссылок высобождает память с отрицательным дикрементом


'''


@mem_check
def func_1_mem_check():
    nums = list(range(50000))
    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    # print(new_arr)


'''
Использование памяти при старте: [18.6171875]
Использование памяти при завершении: [18.62109375]
Инкремент памяти: 0.00078125 Mib
Использование памяти при старте: [18.62109375]
Использование памяти при завершении: [18.62109375]
Инкремент памяти: 0.00078125 Mib
Использование памяти при старте: [18.62109375]
Использование памяти при завершении: [18.62109375]
Инкремент памяти: 0.00078125 Mib
Использование памяти при старте: [18.62109375]
Использование памяти при завершении: [18.62109375]
Инкремент памяти: 0.00078125 Mib
Использование памяти при старте: [18.62109375]
Использование памяти при завершении: [18.62109375]
Инкремент памяти: 0.00078125 Mib

При использовании декаратора с методом memory_usage по замеру расхода памяти 
результат первой функции тот же возникатет дикремент

'''


@mem_check
def func_1_ver_2_mem_check():
    nums = [i for i in range(50000)]
    new_arr = [i for i in range(len(nums)) if nums[i] % 2 == 0]
    # print(new_arr)
    del nums
    del new_arr


func_1()
func_1_ver_2()

func_1_mem_check()
print('_' * 100)
func_1_ver_2_mem_check()

'''
Использование памяти при старте: [18.62109375]
Использование памяти при завершении: [18.62109375]
Инкремент памяти: 0.0 Mib
Использование памяти при старте: [18.62109375]
Использование памяти при завершении: [18.62109375]
Инкремент памяти: 0.0 Mib
Использование памяти при старте: [18.62109375]
Использование памяти при завершении: [18.62109375]
Инкремент памяти: 0.0 Mib
Использование памяти при старте: [18.62109375]
Использование памяти при завершении: [18.62109375]
Инкремент памяти: 0.0 Mib
Использование памяти при старте: [18.62109375]
Использование памяти при завершении: [18.62109375]
Инкремент памяти: 0.0 Mib

После оптимизации видно что декримента нет это значит память расхотуется отимально

'''
